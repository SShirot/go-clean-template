// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"github.com/evrone/go-clean-template/config"
	"github.com/evrone/go-clean-template/internal/usecase"
	"github.com/evrone/go-clean-template/pkg/grpcserver"
	"github.com/evrone/go-clean-template/pkg/httpserver"
	"github.com/evrone/go-clean-template/pkg/logger"
	server2 "github.com/evrone/go-clean-template/pkg/nats/nats_rpc/server"
	"github.com/evrone/go-clean-template/pkg/postgres"
	"github.com/evrone/go-clean-template/pkg/rabbitmq/rmq_rpc/server"
)

// Injectors from wire.go:

// InitializeApp creates a new App instance with all dependencies injected
func InitializeApp(cfg *config.Config) (*App, error) {
	loggerInterface := NewLogger(cfg)
	postgres, err := NewPostgres(cfg, loggerInterface)
	if err != nil {
		return nil, err
	}
	server := NewHTTPServer(cfg, loggerInterface)
	grpcserverServer := NewGRPCServer(cfg, loggerInterface)
	translationRepo := NewTranslationRepo(postgres)
	translationWebAPI := NewTranslationWebAPI()
	translation := NewTranslationUseCase(translationRepo, translationWebAPI)
	serverServer, err := NewRabbitMQServer(cfg, translation, loggerInterface)
	if err != nil {
		return nil, err
	}
	server2, err := NewNATSServer(cfg, translation, loggerInterface)
	if err != nil {
		return nil, err
	}
	app := &App{
		Logger:         loggerInterface,
		Postgres:       postgres,
		HTTPServer:     server,
		GRPCServer:     grpcserverServer,
		RabbitMQServer: serverServer,
		NATSServer:     server2,
		TranslationUC:  translation,
	}
	return app, nil
}

// wire.go:

// App is the main application struct
type App struct {
	Logger         logger.Interface
	Postgres       *postgres.Postgres
	HTTPServer     *httpserver.Server
	GRPCServer     *grpcserver.Server
	RabbitMQServer *server.Server
	NATSServer     *server2.Server
	TranslationUC  usecase.Translation
}
